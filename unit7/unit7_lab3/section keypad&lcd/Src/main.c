/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
#include "STM32f103C6_GPIO_DRIVER.h"
#include "STM32f103x6.h"
#include "lcd.h"
#include "keypad.h"

// Number from 1 to 9 in Hexadecimal For a common anode seven-segment display
#define Zero   0xC0  // 0b11000000
#define One    0xF9  // 0b11111001
#define Two    0xA4  // 0b10100100
#define Three  0xB0  // 0b10110000
#define Four   0x99  // 0b10011001
#define Five   0x92  // 0b10010010
#define Six    0x82  // 0b10000010
#define Seven  0xF8  // 0b11111000
#define Eight  0x80  // 0b10000000
#define Nine   0x90  // 0b10010000


void init_GPIO()
{





	PinConfig.GPIO_MODE=GPIO_MODE_Output_PP;
	PinConfig.GPIO_PinNumber=GPIO_PIN_9;
	PinConfig.GPIO_Output_Speed=GPIO_SPEED_10MHz;
	MCAL_GPIO_Init(GPIOB,&PinConfig);

	PinConfig.GPIO_MODE=GPIO_MODE_Output_PP;
	PinConfig.GPIO_PinNumber=GPIO_PIN_10;
	PinConfig.GPIO_Output_Speed=GPIO_SPEED_10MHz;
	MCAL_GPIO_Init(GPIOB,&PinConfig);

	PinConfig.GPIO_MODE=GPIO_MODE_Output_PP;
	PinConfig.GPIO_PinNumber=GPIO_PIN_11;
	PinConfig.GPIO_Output_Speed=GPIO_SPEED_10MHz;
	MCAL_GPIO_Init(GPIOB,&PinConfig);

	PinConfig.GPIO_MODE=GPIO_MODE_Output_PP;
	PinConfig.GPIO_PinNumber=GPIO_PIN_12;
	PinConfig.GPIO_Output_Speed=GPIO_SPEED_10MHz;
	MCAL_GPIO_Init(GPIOB,&PinConfig);

	PinConfig.GPIO_MODE=GPIO_MODE_Output_PP;
	PinConfig.GPIO_PinNumber=GPIO_PIN_13;
	PinConfig.GPIO_Output_Speed=GPIO_SPEED_10MHz;
	MCAL_GPIO_Init(GPIOB,&PinConfig);

	PinConfig.GPIO_MODE=GPIO_MODE_Output_PP;
	PinConfig.GPIO_PinNumber=GPIO_PIN_14;
	PinConfig.GPIO_Output_Speed=GPIO_SPEED_10MHz;
	MCAL_GPIO_Init(GPIOB,&PinConfig);

	PinConfig.GPIO_MODE=GPIO_MODE_Output_PP;
	PinConfig.GPIO_PinNumber=GPIO_PIN_15;
	PinConfig.GPIO_Output_Speed=GPIO_SPEED_10MHz;
	MCAL_GPIO_Init(GPIOB,&PinConfig);



}
void init_clock()
{
	//GPIO enable clock
	RCC_GPIOA_CLK_ENABLE();
	RCC_GPIOB_CLK_ENABLE();
}

int main(void)
{
	init_clock();
	init_GPIO();
	LCD_INIT();
	uint8_t seg[]={Zero,One,Two,Three,Four,Five,Six,Seven,Eight,Nine};
	uint8_t lc[]={'1','2','3','4','5','6','7','8','9'};
	for (uint8_t i=0;i<10;i++)
	{
		MCAL_GPIO_Write_Port(GPIOB ,seg[i]<<9);
		LCD_WRITE_CHAR(lc[i]);
		delay(40);
	}
	LCD_clear_screen();

	Keypad_init();
	unsigned char key_pressed;
	//	volatile char flag =1;
	//	MCAL_GPIO_Write_PIN(GPIOB,GPIO_PIN_13, 0);
	//	MCAL_GPIO_Write_PIN(GPIOB,GPIO_PIN_1, 0);
	LCD_WRITE_STRING("keypad is ready!!");
	delay(50);
	LCD_clear_screen();
	while (1){


		key_pressed = Keypad_getkey();
		switch(key_pressed){
		case 'A':
			break;
		case '?':
			LCD_clear_screen();
			break;
		default:
			LCD_WRITE_CHAR(key_pressed);
			break;
		}
		//		if ((MCAL_GPIO_Read_PIN(GPIOA, GPIO_PIN_1)))
		//		{
		//			if (flag)
		//				MCAL_GPIO_Toggle_PIN(GPIOB,GPIO_PIN_1);
		//			flag=0;
		//
		//		}
		//		else flag=1;
		//		if ((MCAL_GPIO_Read_PIN(GPIOA, GPIO_PIN_13)))
		//		{
		//			MCAL_GPIO_Toggle_PIN(GPIOB,GPIO_PIN_13);
		//
		//
		//		}

		delay(10);

	}
}

